# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

input AccountCreateManyUserInput {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
}

input AccountCreateManyUserInputEnvelope {
  data: [AccountCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input AccountCreateNestedManyWithoutUserInput {
  connect: [AccountWhereUniqueInput!]
  connectOrCreate: [AccountCreateOrConnectWithoutUserInput!]
  create: [AccountCreateWithoutUserInput!]
  createMany: AccountCreateManyUserInputEnvelope
}

input AccountCreateOrConnectWithoutUserInput {
  create: AccountCreateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountCreateWithoutUserInput {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
}

input AccountListRelationFilter {
  every: AccountWhereInput
  none: AccountWhereInput
  some: AccountWhereInput
}

input AccountOrderByRelationAggregateInput {
  _count: SortOrder
}

input AccountProviderProviderAccountIdCompoundUniqueInput {
  provider: String!
  providerAccountId: String!
}

input AccountScalarWhereInput {
  AND: [AccountScalarWhereInput!]
  NOT: [AccountScalarWhereInput!]
  OR: [AccountScalarWhereInput!]
  access_token: StringNullableFilter
  expires_at: IntNullableFilter
  id: StringFilter
  id_token: StringNullableFilter
  oauth_token: StringNullableFilter
  oauth_token_secret: StringNullableFilter
  provider: StringFilter
  providerAccountId: StringFilter
  refresh_token: StringNullableFilter
  scope: StringNullableFilter
  session_state: StringNullableFilter
  token_type: StringNullableFilter
  type: StringFilter
  userId: StringFilter
}

input AccountUpdateManyMutationInput {
  access_token: NullableStringFieldUpdateOperationsInput
  expires_at: NullableIntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  id_token: NullableStringFieldUpdateOperationsInput
  oauth_token: NullableStringFieldUpdateOperationsInput
  oauth_token_secret: NullableStringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  refresh_token: NullableStringFieldUpdateOperationsInput
  scope: NullableStringFieldUpdateOperationsInput
  session_state: NullableStringFieldUpdateOperationsInput
  token_type: NullableStringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input AccountUpdateManyWithWhereWithoutUserInput {
  data: AccountUpdateManyMutationInput!
  where: AccountScalarWhereInput!
}

input AccountUpdateManyWithoutUserInput {
  connect: [AccountWhereUniqueInput!]
  connectOrCreate: [AccountCreateOrConnectWithoutUserInput!]
  create: [AccountCreateWithoutUserInput!]
  createMany: AccountCreateManyUserInputEnvelope
  delete: [AccountWhereUniqueInput!]
  deleteMany: [AccountScalarWhereInput!]
  disconnect: [AccountWhereUniqueInput!]
  set: [AccountWhereUniqueInput!]
  update: [AccountUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [AccountUpdateManyWithWhereWithoutUserInput!]
  upsert: [AccountUpsertWithWhereUniqueWithoutUserInput!]
}

input AccountUpdateWithWhereUniqueWithoutUserInput {
  data: AccountUpdateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountUpdateWithoutUserInput {
  access_token: NullableStringFieldUpdateOperationsInput
  expires_at: NullableIntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  id_token: NullableStringFieldUpdateOperationsInput
  oauth_token: NullableStringFieldUpdateOperationsInput
  oauth_token_secret: NullableStringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  refresh_token: NullableStringFieldUpdateOperationsInput
  scope: NullableStringFieldUpdateOperationsInput
  session_state: NullableStringFieldUpdateOperationsInput
  token_type: NullableStringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input AccountUpsertWithWhereUniqueWithoutUserInput {
  create: AccountCreateWithoutUserInput!
  update: AccountUpdateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  access_token: StringNullableFilter
  expires_at: IntNullableFilter
  id: StringFilter
  id_token: StringNullableFilter
  oauth_token: StringNullableFilter
  oauth_token_secret: StringNullableFilter
  provider: StringFilter
  providerAccountId: StringFilter
  refresh_token: StringNullableFilter
  scope: StringNullableFilter
  session_state: StringNullableFilter
  token_type: StringNullableFilter
  type: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

input AccountWhereUniqueInput {
  id: String
  provider_providerAccountId: AccountProviderProviderAccountIdCompoundUniqueInput
}

type AffectedRowsOutput {
  count: Int!
}

type AggregatePost {
  _count: PostCountAggregate
  _max: PostMaxAggregate
  _min: PostMinAggregate
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

type Mutation {
  createManyPost(data: [PostCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createPost(data: PostCreateInput!): Post!
  deleteManyPost(where: PostWhereInput): AffectedRowsOutput!
  deletePost(where: PostWhereUniqueInput!): Post
  updateManyPost(data: PostUpdateManyMutationInput!, where: PostWhereInput): AffectedRowsOutput!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  upsertPost(create: PostCreateInput!, update: PostUpdateInput!, where: PostWhereUniqueInput!): Post!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Post {
  _count: PostCount
  body: String!
  createdAt: DateTime!
  id: String!
  tags(cursor: TagWhereUniqueInput, distinct: [TagScalarFieldEnum!], orderBy: [TagOrderByWithRelationInput!], skip: Int, take: Int, where: TagWhereInput): [Tag!]!
  title: String!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type PostCount {
  tags: Int!
}

type PostCountAggregate {
  _all: Int!
  body: Int!
  createdAt: Int!
  id: Int!
  title: Int!
  updatedAt: Int!
  userId: Int!
}

input PostCountOrderByAggregateInput {
  body: SortOrder
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostCreateInput {
  body: String!
  createdAt: DateTime
  id: String
  tags: TagCreateNestedManyWithoutPostInput
  title: String!
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutProjectsInput!
}

input PostCreateManyInput {
  body: String!
  createdAt: DateTime
  id: String
  title: String!
  updatedAt: DateTime
  userId: String!
}

type PostGroupBy {
  _count: PostCountAggregate
  _max: PostMaxAggregate
  _min: PostMinAggregate
  body: String!
  createdAt: DateTime!
  id: String!
  title: String!
  updatedAt: DateTime!
  userId: String!
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

type PostMaxAggregate {
  body: String
  createdAt: DateTime
  id: String
  title: String
  updatedAt: DateTime
  userId: String
}

input PostMaxOrderByAggregateInput {
  body: SortOrder
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type PostMinAggregate {
  body: String
  createdAt: DateTime
  id: String
  title: String
  updatedAt: DateTime
  userId: String
}

input PostMinOrderByAggregateInput {
  body: SortOrder
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostOrderByRelationAggregateInput {
  _count: SortOrder
}

input PostOrderByWithAggregationInput {
  _count: PostCountOrderByAggregateInput
  _max: PostMaxOrderByAggregateInput
  _min: PostMinOrderByAggregateInput
  body: SortOrder
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostOrderByWithRelationInput {
  body: SortOrder
  createdAt: SortOrder
  id: SortOrder
  tags: TagOrderByRelationAggregateInput
  title: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input PostRelationFilter {
  is: PostWhereInput
  isNot: PostWhereInput
}

enum PostScalarFieldEnum {
  body
  createdAt
  id
  title
  updatedAt
  userId
}

input PostScalarWhereWithAggregatesInput {
  AND: [PostScalarWhereWithAggregatesInput!]
  NOT: [PostScalarWhereWithAggregatesInput!]
  OR: [PostScalarWhereWithAggregatesInput!]
  body: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input PostUpdateInput {
  body: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  tags: TagUpdateManyWithoutPostInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutProjectsInput
}

input PostUpdateManyMutationInput {
  body: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostWhereInput {
  AND: [PostWhereInput!]
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  body: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  tags: TagListRelationFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: StringFilter
}

input PostWhereUniqueInput {
  id: String
}

type Query {
  aggregatePost(cursor: PostWhereUniqueInput, orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): AggregatePost!
  findFirstPost(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): Post
  groupByPost(by: [PostScalarFieldEnum!]!, having: PostScalarWhereWithAggregatesInput, orderBy: [PostOrderByWithAggregationInput!], skip: Int, take: Int, where: PostWhereInput): [PostGroupBy!]!
  post(where: PostWhereUniqueInput!): Post
  posts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
}

enum QueryMode {
  default
  insensitive
}

input SessionCreateManyUserInput {
  expires: DateTime!
  id: String
  sessionToken: String!
}

input SessionCreateManyUserInputEnvelope {
  data: [SessionCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input SessionCreateNestedManyWithoutUserInput {
  connect: [SessionWhereUniqueInput!]
  connectOrCreate: [SessionCreateOrConnectWithoutUserInput!]
  create: [SessionCreateWithoutUserInput!]
  createMany: SessionCreateManyUserInputEnvelope
}

input SessionCreateOrConnectWithoutUserInput {
  create: SessionCreateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionCreateWithoutUserInput {
  expires: DateTime!
  id: String
  sessionToken: String!
}

input SessionListRelationFilter {
  every: SessionWhereInput
  none: SessionWhereInput
  some: SessionWhereInput
}

input SessionOrderByRelationAggregateInput {
  _count: SortOrder
}

input SessionScalarWhereInput {
  AND: [SessionScalarWhereInput!]
  NOT: [SessionScalarWhereInput!]
  OR: [SessionScalarWhereInput!]
  expires: DateTimeFilter
  id: StringFilter
  sessionToken: StringFilter
  userId: StringFilter
}

input SessionUpdateManyMutationInput {
  expires: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  sessionToken: StringFieldUpdateOperationsInput
}

input SessionUpdateManyWithWhereWithoutUserInput {
  data: SessionUpdateManyMutationInput!
  where: SessionScalarWhereInput!
}

input SessionUpdateManyWithoutUserInput {
  connect: [SessionWhereUniqueInput!]
  connectOrCreate: [SessionCreateOrConnectWithoutUserInput!]
  create: [SessionCreateWithoutUserInput!]
  createMany: SessionCreateManyUserInputEnvelope
  delete: [SessionWhereUniqueInput!]
  deleteMany: [SessionScalarWhereInput!]
  disconnect: [SessionWhereUniqueInput!]
  set: [SessionWhereUniqueInput!]
  update: [SessionUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [SessionUpdateManyWithWhereWithoutUserInput!]
  upsert: [SessionUpsertWithWhereUniqueWithoutUserInput!]
}

input SessionUpdateWithWhereUniqueWithoutUserInput {
  data: SessionUpdateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionUpdateWithoutUserInput {
  expires: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  sessionToken: StringFieldUpdateOperationsInput
}

input SessionUpsertWithWhereUniqueWithoutUserInput {
  create: SessionCreateWithoutUserInput!
  update: SessionUpdateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionWhereInput {
  AND: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  expires: DateTimeFilter
  id: StringFilter
  sessionToken: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

input SessionWhereUniqueInput {
  id: String
  sessionToken: String
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Tag {
  name: String!
  postId: String
}

input TagCreateManyPostInput {
  name: String!
}

input TagCreateManyPostInputEnvelope {
  data: [TagCreateManyPostInput!]!
  skipDuplicates: Boolean
}

input TagCreateNestedManyWithoutPostInput {
  connect: [TagWhereUniqueInput!]
  connectOrCreate: [TagCreateOrConnectWithoutPostInput!]
  create: [TagCreateWithoutPostInput!]
  createMany: TagCreateManyPostInputEnvelope
}

input TagCreateOrConnectWithoutPostInput {
  create: TagCreateWithoutPostInput!
  where: TagWhereUniqueInput!
}

input TagCreateWithoutPostInput {
  name: String!
}

input TagListRelationFilter {
  every: TagWhereInput
  none: TagWhereInput
  some: TagWhereInput
}

input TagOrderByRelationAggregateInput {
  _count: SortOrder
}

input TagOrderByWithRelationInput {
  Post: PostOrderByWithRelationInput
  name: SortOrder
  postId: SortOrder
}

enum TagScalarFieldEnum {
  name
  postId
}

input TagScalarWhereInput {
  AND: [TagScalarWhereInput!]
  NOT: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
  name: StringFilter
  postId: StringNullableFilter
}

input TagUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
}

input TagUpdateManyWithWhereWithoutPostInput {
  data: TagUpdateManyMutationInput!
  where: TagScalarWhereInput!
}

input TagUpdateManyWithoutPostInput {
  connect: [TagWhereUniqueInput!]
  connectOrCreate: [TagCreateOrConnectWithoutPostInput!]
  create: [TagCreateWithoutPostInput!]
  createMany: TagCreateManyPostInputEnvelope
  delete: [TagWhereUniqueInput!]
  deleteMany: [TagScalarWhereInput!]
  disconnect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  update: [TagUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [TagUpdateManyWithWhereWithoutPostInput!]
  upsert: [TagUpsertWithWhereUniqueWithoutPostInput!]
}

input TagUpdateWithWhereUniqueWithoutPostInput {
  data: TagUpdateWithoutPostInput!
  where: TagWhereUniqueInput!
}

input TagUpdateWithoutPostInput {
  name: StringFieldUpdateOperationsInput
}

input TagUpsertWithWhereUniqueWithoutPostInput {
  create: TagCreateWithoutPostInput!
  update: TagUpdateWithoutPostInput!
  where: TagWhereUniqueInput!
}

input TagWhereInput {
  AND: [TagWhereInput!]
  NOT: [TagWhereInput!]
  OR: [TagWhereInput!]
  Post: PostRelationFilter
  name: StringFilter
  postId: StringNullableFilter
}

input TagWhereUniqueInput {
  name: String
}

type User {
  _count: UserCount
  emailVerified: DateTime
  id: String!
  image: String
  name: String
}

type UserCount {
  accounts: Int!
  projects: Int!
  sessions: Int!
}

input UserCreateNestedOneWithoutProjectsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutProjectsInput
  create: UserCreateWithoutProjectsInput
}

input UserCreateOrConnectWithoutProjectsInput {
  create: UserCreateWithoutProjectsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutProjectsInput {
  accounts: AccountCreateNestedManyWithoutUserInput
  email: String
  emailVerified: DateTime
  id: String
  image: String
  name: String
  sessions: SessionCreateNestedManyWithoutUserInput
}

input UserOrderByWithRelationInput {
  accounts: AccountOrderByRelationAggregateInput
  email: SortOrder
  emailVerified: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  projects: PostOrderByRelationAggregateInput
  sessions: SessionOrderByRelationAggregateInput
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserUpdateOneRequiredWithoutProjectsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutProjectsInput
  create: UserCreateWithoutProjectsInput
  update: UserUpdateWithoutProjectsInput
  upsert: UserUpsertWithoutProjectsInput
}

input UserUpdateWithoutProjectsInput {
  accounts: AccountUpdateManyWithoutUserInput
  email: NullableStringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  sessions: SessionUpdateManyWithoutUserInput
}

input UserUpsertWithoutProjectsInput {
  create: UserCreateWithoutProjectsInput!
  update: UserUpdateWithoutProjectsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  accounts: AccountListRelationFilter
  email: StringNullableFilter
  emailVerified: DateTimeNullableFilter
  id: StringFilter
  image: StringNullableFilter
  name: StringNullableFilter
  projects: PostListRelationFilter
  sessions: SessionListRelationFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}
